syntax = "proto3";

import "scalapb/scalapb.proto";

option (scalapb.options) = {
  scope: FILE
  package_name: "transaction.protocol"
  flat_package: true
};

message Enqueue {
    option (scalapb.message).extends = "transaction.Command";
    option (scalapb.message).companion_extends = "transaction.Command";

    string id = 1;
    map<string, VersionedValue> rs = 2;
    map<string, VersionedValue> ws = 3;
}

message Transaction {
    option (scalapb.message).extends = "transaction.Command";
    option (scalapb.message).companion_extends = "transaction.Command";

    string id = 1;
    map<string, Enqueue> partitions = 2;
}

message PartitionResult {
    option (scalapb.message).extends = "transaction.Command";
    option (scalapb.message).companion_extends = "transaction.Command";

    repeated string conflicted = 1;
    repeated string applied = 2;
}

message Batch {
    option (scalapb.message).extends = "transaction.Command";
    option (scalapb.message).companion_extends = "transaction.Command";

    string coordinator = 1;
    repeated string transactions = 2;
}

message Ack {
    option (scalapb.message).extends = "transaction.Command";
    option (scalapb.message).companion_extends = "transaction.Command";
}

message Read {
    option (scalapb.message).extends = "transaction.Command";
    option (scalapb.message).companion_extends = "transaction.Command";

    repeated string keys = 1;
}

message VersionedValue {
    option (scalapb.message).extends = "transaction.Command";
    option (scalapb.message).companion_extends = "transaction.Command";

    string version = 1;
    uint64 value = 2;
}

message ReadResult {
    option (scalapb.message).extends = "transaction.Command";
    option (scalapb.message).companion_extends = "transaction.Command";

    map<string, VersionedValue > values = 1;
}

message Nack {
    option (scalapb.message).extends = "transaction.Command";
    option (scalapb.message).companion_extends = "transaction.Command";
}
